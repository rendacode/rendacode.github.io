<!DOCTYPE html>
<html lang="zh-CN">
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>任大的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

</head>

<body>
  

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div id="l_body">
    <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Volantis</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              id="v4getting-started">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              id="faqs">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              id="examples">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              id="contributors">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              id="https:githubcomvolantis-xhexo-theme-volantis">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

    <div id='safearea'>
      <div class='body-wrapper' id="pjax-container">
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
  </div>


  
  <h1 id="万字好文，电商秒杀系统架构分析与实战！"><a href="#万字好文，电商秒杀系统架构分析与实战！" class="headerlink" title="万字好文，电商秒杀系统架构分析与实战！"></a>万字好文，电商秒杀系统架构分析与实战！</h1><blockquote>
<p>本文由 <a href="%5Bhttp://ksria.com/simpread/%5D(http://ksria.com/simpread/)">简悦 SimpRead</a> 转码， 原文地址 <a href="%5Bhttps://mp.weixin.qq.com/s/Nbm1vQvPXVY_-VFesC5yvw%5D(https://mp.weixin.qq.com/s/Nbm1vQvPXVY_-VFesC5yvw)">mp.weixin.qq.com</a></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1983805/1604503316770-0312f80c-41c6-4fb9-a47f-eb174aa721a7.jpeg#align=left&display=inline&height=439&margin=%5Bobject%20Object%5D&originHeight=439&originWidth=1080&size=0&status=done&style=none&width=1080" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/1983805/1604503316770-0312f80c-41c6-4fb9-a47f-eb174aa721a7.jpeg#align=left&display=inline&height=439&margin=%5Bobject%20Object%5D&originHeight=439&originWidth=1080&size=0&status=done&style=none&width=1080" srcset="data:image/png;base64,666"><em>来源：<a target="_blank" rel="noopener" href="https://my.oschina.net/xianggao/blog/524943">https://my.oschina.net/xianggao/blog/524943</a></em></p>
<h1 id="1-秒杀业务分析"><a href="#1-秒杀业务分析" class="headerlink" title="1 秒杀业务分析"></a>1 秒杀业务分析</h1><ol>
<li><strong>正常电子商务流程</strong></li>
</ol>
<blockquote>
<p>（1）查询商品； <br>（2）创建订单； <br>（3）扣减库存； <br>（4）更新订单； <br>（5）付款； <br>（6）卖家发货；</p>
</blockquote>
<ol start="2">
<li><strong>秒杀业务的特性</strong></li>
</ol>
<blockquote>
<p>（1）低廉价格； <br>（2）大幅推广； <br>（3）瞬时售空； <br>（4）一般是定时上架； <br>（5）时间短、瞬时并发量高；</p>
</blockquote>
<h1 id="2-秒杀技术挑战"><a href="#2-秒杀技术挑战" class="headerlink" title="2 秒杀技术挑战"></a>2 秒杀技术挑战</h1><p>假设某网站秒杀活动只推出一件商品，预计会吸引 1 万人参加活动，也就说最大并发请求数是 10000，秒杀系统需要面对的技术挑战有：</p>
<ol>
<li><strong>对现有网站业务造成冲击</strong></li>
</ol>
<p>秒杀活动只是网站营销的一个附加活动，这个活动具有时间短，并发访问量大的特点，如果和网站原有应用部署在一起，必然会对现有业务造成冲击，稍有不慎可能导致整个网站瘫痪。</p>
<blockquote>
<p><strong>解决方案</strong> ：将秒杀系统独立部署，甚至 <strong>使用独立域名，使其与网站完全隔离</strong> 。</p>
</blockquote>
<ol start="2">
<li><strong>高并发下的应用、数据库负载</strong></li>
</ol>
<p>用户在秒杀开始前，通过不停刷新浏览器页面以保证不会错过秒杀，这些请求如果按照一般的网站应用架构，访问应用服务器、连接数据库，会对应用服务器和数据库服务器造成负载压力。</p>
<blockquote>
<p><strong>解决方案</strong> ：重新设计秒杀商品页面，不使用网站原来的商品详细页面， <strong>页面内容静态化，用户请求不需要经过应用服务</strong> 。</p>
</blockquote>
<ol start="3">
<li><strong>突然增加的网络及服务器带宽</strong></li>
</ol>
<p>假设商品页面大小 200K（主要是商品图片大小），那么需要的网络和服务器带宽是 2G（200K×10000），这些网络带宽是因为秒杀活动新增的，超过网站平时使用的带宽。</p>
<blockquote>
<p><strong>解决方案</strong> ：因为秒杀新增的网络带宽，必须和运营商重新购买或者租借。为了减轻网站服务器的压力，<br><strong>需要将秒杀商品页面缓存在 CDN，同样需要和 CDN 服务商临时租借新增的出口带宽</strong> 。</p>
</blockquote>
<ol start="4">
<li><strong>直接下单</strong></li>
</ol>
<p>秒杀的游戏规则是到了秒杀才能开始对商品下单购买，在此时间点之前，只能浏览商品信息，不能下单。而下单页面也是一个普通的 URL，如果得到这个 URL，不用等到秒杀开始就可以下单了。</p>
<blockquote>
<p><strong>解决方案</strong> ：为了避免用户直接访问下单页面 URL，需要将改 URL 动态化，即使秒杀系统的开发者也无法在秒杀开始前访问下单页面的 URL。办法是在<br><strong>下单页面 URL 加入由服务器端生成的随机数作为参数，在秒杀开始的时候才能得到</strong> 。</p>
</blockquote>
<ol start="5">
<li><strong>如何控制秒杀商品页面购买按钮的点亮</strong></li>
</ol>
<p>购买按钮只有在秒杀开始的时候才能点亮，在此之前是灰色的。如果该页面是动态生成的，当然可以在服务器端构造响应页面输出，控制该按钮是灰色还是点亮，但是为了减轻服务器端负载压力，更好地利用 CDN、反向代理等性能优化手段，该页面被设计为静态页面，缓存在 CDN、反向代理服务器上，甚至用户浏览器上。秒杀开始时，用户刷新页面，请求根本不会到达应用服务器。</p>
<blockquote>
<p><strong>解决方案</strong> ：使用 JavaScript 脚本控制，<br><strong>在秒杀商品静态页面中加入一个 JavaScript 文件引用，该 JavaScript 文件中包含秒杀开始标志为否</strong><br>；当秒杀开始的时候生成一个新的 JavaScript 文件（ <strong>文件名保持不变，只是内容不一样</strong> ），更新秒杀开始标志为是，<br><strong>加入下单页面的 URL 及随机数参数（这个随机数只会产生一个，即所有人看到的 URL 都是同一个，服务器端可以用 redis 这种分布式缓存服务器来保存随机数）</strong><br>，并被用户浏览器加载，控制秒杀商品页面的展示。<br><strong>这个 JavaScript 文件的加载可以加上随机版本号（例如 xx.js?v=32353823），这样就不会被浏览器、CDN 和反向代理服务器缓存</strong> 。<br>这个 JavaScript 文件非常小，即使每次浏览器刷新都访问 JavaScript 文件服务器也不会对服务器集群和网络带宽造成太大压力。</p>
</blockquote>
<ol start="6">
<li><strong>如何只允许第一个提交的订单被发送到订单子系统</strong></li>
</ol>
<p>由于最终能够成功秒杀到商品的用户只有一个，因此需要在用户提交订单时，检查是否已经有订单提交。如果已经有订单提交成功，则需要更新<br>JavaScript 文件，更新秒杀开始标志为否，购买按钮变灰。事实上，由于最终能够成功提交订单的用户只有一个，为了减轻下单页面服务器的负载压力，可以<br><strong>控制进入下单页面的入口，只有少数用户能进入下单页面，其他用户直接进入秒杀结束页面</strong> 。</p>
<blockquote>
<p><strong>解决方案</strong><br>：假设下单服务器集群有 10 台服务器，每台服务器只接受最多 10 个下单请求。在还没有人提交订单成功之前，如果一台服务器已经有十单了，而有的一单都没处理，可能出现的用户体验不佳的场景是用户第一次点击购买按钮进入已结束页面，再刷新一下页面，有可能被一单都没有处理的服务器处理，进入了填写订单的页面，<br><strong>可以考虑通过 cookie 的方式来应对，符合一致性原则</strong> 。当然可以 <strong>采用最少连接的负载均衡算法</strong> ，出现上述情况的概率大大降低。</p>
</blockquote>
<ol start="7">
<li><strong>如何进行下单前置检查</strong></li>
</ol>
<ul>
<li><strong>下单服务器检查本机已处理的下单请求数目：</strong></li>
</ul>
<blockquote>
<p>如果超过 10 条，直接返回已结束页面给用户；<br>如果未超过 10 条，则用户可进入填写订单及确认页面；</p>
</blockquote>
<ul>
<li><strong>检查全局已提交订单数目：</strong></li>
</ul>
<blockquote>
<p>已超过秒杀商品总数，返回已结束页面给用户；<br>未超过秒杀商品总数，提交到子订单系统；</p>
</blockquote>
<ol start="8">
<li><strong>秒杀一般是定时上架</strong></li>
</ol>
<p>该功能实现方式很多。不过目前比较好的方式是：提前设定好商品的上架时间，用户可以在前台看到该商品，但是无法点击 “立即购买” 的按钮。但是需要考虑的是，<br><strong>有人可以绕过前端的限制，直接通过 URL 的方式发起购买</strong><br>，这就需要在前台商品页面，以及 bug 页面到后端的数据库，都要进行时钟同步。越在后端控制，安全性越高。</p>
<p><strong>定时秒杀的话，就要避免卖家在秒杀前对商品做编辑带来的不可预期的影响</strong> 。这种特殊的变更需要多方面评估。一般禁止编辑，如需变更，可以走数据订正的流程。</p>
<ol start="9">
<li><strong>减库存的操作</strong></li>
</ol>
<p>有两种选择，一种是 <strong>拍下减库存</strong> 另外一种是 <strong>付款减库存</strong> ；目前采用的 <strong>“拍下减库存”</strong> 的方式，拍下就是一瞬间的事，对用户体验会好些。</p>
<ol start="10">
<li><strong>库存会带来 “超卖” 的问题：售出数量多于库存数量</strong></li>
</ol>
<p>由于库存并发更新的问题，导致在实际库存已经不足的情况下，库存依然在减，导致卖家的商品卖得件数超过秒杀的预期。方案：<strong>采用乐观锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update auction_auctions set  </span><br><span class="line">    quantity &#x3D; #inQuantity#  </span><br><span class="line">    where auction_id &#x3D; #itemId# and quantity &#x3D; #dbQuantity#</span><br></pre></td></tr></table></figure>


<p><strong>还有一种方式，会更好些，叫做尝试扣减库存，扣减库存成功才会进行下单逻辑：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update auction_auctions set   </span><br><span class="line">    quantity &#x3D; quantity-#count#   </span><br><span class="line">    where auction_id &#x3D; #itemId# and quantity &gt;&#x3D; #count#</span><br></pre></td></tr></table></figure>


<ol start="11">
<li><strong>秒杀器的应对</strong></li>
</ol>
<p>秒杀器一般下单个购买及其迅速，根据购买记录可以甄别出一部分。可以通过校验码达到一定的方法，这就要求校验码足够安全，不被破解，采用的方式有：<br><strong>秒杀专用验证码，电视公布验证码，秒杀答题</strong> 。</p>
<h1 id="3-秒杀架构原则"><a href="#3-秒杀架构原则" class="headerlink" title="3 秒杀架构原则"></a>3 秒杀架构原则</h1><ol>
<li><strong>尽量将请求拦截在系统上游</strong></li>
</ol>
<p>传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小【一趟火车其实只有 2000 张票，200w 个人来买，基本没有人能买成功，请求有效率为 0】。</p>
<ol start="2">
<li><strong>读多写少的常用多使用缓存</strong></li>
</ol>
<p>这是一个典型的 <strong>读多写少</strong><br>的应用场景【一趟火车其实只有 2000 张票，200w 个人来买，最多 2000 个人下单成功，其他人都是查询库存，写比例只有 0.1%，读比例占 99.9%】，<br><strong>非常适合使用缓存</strong> 。</p>
<h1 id="4-秒杀架构设计"><a href="#4-秒杀架构设计" class="headerlink" title="4 秒杀架构设计"></a>4 秒杀架构设计</h1><p>秒杀系统为秒杀而设计，不同于一般的网购行为，参与秒杀活动的用户更关心的是 <strong>如何能快速刷新商品页面，在秒杀开始的时候抢先进入下单页面</strong><br>，而不是商品详情等用户体验细节，因此秒杀系统的页面设计应尽可能简单。</p>
<p>商品页面中的购买按钮只有在秒杀活动开始的时候才变亮，在此之前及秒杀商品卖出后，该按钮都是灰色的，不可以点击。</p>
<p>下单表单也尽可能简单，购买数量只能是一个且不可以修改，送货地址和付款方式都使用用户默认设置，没有默认也可以不填，允许等订单提交后修改；只有第一个提交的订单发送给网站的订单子系统，其余用户提交订单后只能看到秒杀结束页面。</p>
<p><strong>要做一个这样的秒杀系统，业务会分为两个阶段：</strong></p>
<blockquote>
<p>第一个阶段是秒杀开始前某个时间到秒杀开始， 这个阶段可以称之为 <strong>准备阶段，用户在准备阶段等待秒杀</strong> ；<br>第二个阶段就是秒杀开始到所有参与秒杀的用户获得秒杀结果， 这个就称为 <strong>秒杀阶段</strong> 吧。</p>
</blockquote>
<h2 id="4-1-前端层设计"><a href="#4-1-前端层设计" class="headerlink" title="4.1 前端层设计"></a>4.1 前端层设计</h2><p>首先要有一个展示秒杀商品的页面，在这个页面上做一个秒杀活动开始的倒计时， <strong>在准备阶段内用户会陆续打开这个秒杀的页面， 并且可能不停的刷新页面</strong><br>。这里需要考虑两个问题：</p>
<ol>
<li><strong>第一个是秒杀页面的展示</strong></li>
</ol>
<p>我们知道一个 html 页面还是比较大的，即使做了压缩，http 头和内容的大小也可能高达数十 K，加上其他的 css，<br>js，图片等资源，如果同时有几千万人参与一个商品的抢购，一般机房带宽也就只有 1G<br>10G，<strong>网络带宽就极有可能成为瓶颈</strong>，所以这个页面上<strong>各类静态资源首先应分开存放，然后放到 cdn 节点上分散压力</strong>，由于 CDN 节点遍布全国各地，能缓冲掉绝大部分的压力，而且还比机房带宽便宜</p>
<ol start="2">
<li><strong>第二个是倒计时</strong></li>
</ol>
<p>出于性能原因这个 <strong>一般由 js 调用客户端本地时间</strong> ，就有可能出现客户端时钟与服务器时钟不一致，另外服务器之间也是有可能出现时钟不一致。<br><strong>客户端与服务器时钟不一致可以采用客户端定时和服务器同步时间</strong><br>，这里考虑一下性能问题，用于同步时间的接口由于不涉及到后端逻辑，只需要将当前 web 服务器的时间发送给客户端就可以了，因此速度很快，就我以前测试的结果来看，一台标准的 web 服务器 2W+QPS 不会有问题，如果 100W 人同时刷，100W<br>QPS 也只需要 50 台 web，一台硬件 LB 就可以了~，并且 web 服务器群是可以很容易的横向扩展的 (LB+DNS 轮询)，这个接口可以只返回一小段 json 格式的数据，而且可以优化一下减少不必要 cookie 和其他 http 头的信息，所以数据量不会很大，<br><strong>一般来说网络不会成为瓶颈，即使成为瓶颈也可以考虑多机房专线连通，加智能 DNS 的解决方案</strong> ；web 服务器之间时间不同步可以采用统一时间服务器的方式，<br><strong>比如每隔 1 分钟所有参与秒杀活动的 web 服务器就与时间服务器做一次时间同步</strong> 。</p>
<ol start="3">
<li><strong>浏览器层请求拦截</strong></li>
</ol>
<blockquote>
<p>（1） <strong>产品层面</strong> ，用户点击 “查询” 或者 “购票” 后，按钮置灰，禁止用户重复提交请求;<br>（2） <strong>JS 层面</strong> ，限制用户在 x 秒之内只能提交一次请求;</p>
</blockquote>
<h2 id="4-2-站点层设计"><a href="#4-2-站点层设计" class="headerlink" title="4.2 站点层设计"></a>4.2 站点层设计</h2><p>前端层的请求拦截，只能拦住小白用户（不过这是 99% 的用户哟），高端的程序员根本不吃这一套，写个 for 循环，直接调用你后端的 http 请求，怎么整？</p>
<blockquote>
<p>（1） <strong>同一个 uid，限制访问频度</strong> ，做页面缓存，x 秒内到达站点层的请求，均返回同一页面<br>（2） <strong>同一个 item 的查询，例如手机车次</strong> ，做页面缓存，x 秒内到达站点层的请求，均返回同一页面</p>
</blockquote>
<p>如此限流，又有 99% 的流量会被拦截在站点层。</p>
<h2 id="4-3-服务层设计"><a href="#4-3-服务层设计" class="headerlink" title="4.3 服务层设计"></a>4.3 服务层设计</h2><p>站点层的请求拦截，只能拦住普通程序员，高级黑客，假设他控制了 10w 台肉鸡（并且假设买票不需要实名认证），这下 uid 的限制不行了吧？怎么整？</p>
<blockquote>
<p>（1）大哥，我是服务层，我清楚的知道小米只有 1 万部手机，我清楚的知道一列火车只有 2000 张车票，我透 10w 个请求去数据库有什么意义呢？<br><strong>对于写请求，做请求队列，每次只透过有限的写请求去数据层，如果均成功再放下一批，如果库存不够则队列里的写请求全部返回 “已售完”</strong> ；<br>（2） <strong>对于读请求，还用说么？cache 来抗</strong> ，不管是 memcached 还是 redis，单机抗个每秒 10w 应该都是没什么问题的；</p>
</blockquote>
<p>如此限流，只有非常少的写请求，和非常少的读缓存 mis 的请求会透到数据层去，又有 99.9% 的请求被拦住了。</p>
<blockquote>
<ol>
<li><strong>用户请求分发模块</strong> ：使用 Nginx 或 Apache 将用户的请求分发到不同的机器上。</li>
<li><strong>用户请求预处理模块</strong> ：判断商品是不是还有剩余来决定是不是要处理该请求。</li>
<li><strong>用户请求处理模块</strong> ：把通过预处理的请求封装成事务提交给数据库，并返回是否成功。</li>
<li><strong>数据库接口模块</strong> ：该模块是数据库的唯一接口，负责与数据库交互，提供 RPC 接口供查询是否秒杀结束、剩余数量等信息。</li>
</ol>
</blockquote>
<ol>
<li><strong>用户请求预处理模块</strong></li>
</ol>
<p>经过 HTTP 服务器的分发后，单个服务器的负载相对低了一些，但总量依然可能很大，如果后台商品已经被秒杀完毕，那么直接给后来的请求返回秒杀失败即可，不必再进一步发送事务了，示例代码可以如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package seckill;  </span><br><span class="line">    import org.apache.http.HttpRequest;  </span><br><span class="line">    &#x2F;**  </span><br><span class="line">        * 预处理阶段，把不必要的请求直接驳回，必要的请求添加到队列中进入下一阶段.  </span><br><span class="line">        *&#x2F;  </span><br><span class="line">    public class PreProcessor &#123;  </span><br><span class="line">          &#x2F;&#x2F; 商品是否还有剩余  </span><br><span class="line">          private static boolean reminds &#x3D; true;  </span><br><span class="line">          private static void forbidden() &#123;  </span><br><span class="line">              &#x2F;&#x2F; Do something.  </span><br><span class="line">          &#125;  </span><br><span class="line">          public static boolean checkReminds() &#123;  </span><br><span class="line">              if (reminds) &#123;  </span><br><span class="line">                  &#x2F;&#x2F; 远程检测是否还有剩余，该RPC接口应由数据库服务器提供，不必完全严格检查.  </span><br><span class="line">                  if (!RPC.checkReminds()) &#123;  </span><br><span class="line">                      reminds &#x3D; false;  </span><br><span class="line">                  &#125;  </span><br><span class="line">              &#125;  </span><br><span class="line">              return reminds;  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#x2F;**  </span><br><span class="line">         * 每一个HTTP请求都要经过该预处理.  </span><br><span class="line">         *&#x2F;  </span><br><span class="line">          public static void preProcess(HttpRequest request) &#123;  </span><br><span class="line">              if (checkReminds()) &#123;  </span><br><span class="line">                  &#x2F;&#x2F; 一个并发的队列  </span><br><span class="line">                  RequestQueue.queue.add(request);  </span><br><span class="line">              &#125; else &#123;  </span><br><span class="line">                  &#x2F;&#x2F; 如果已经没有商品了，则直接驳回请求即可.  </span><br><span class="line">                  forbidden();  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>并发队列的选择</strong></li>
</ul>
<p>Java 的并发包提供了三个常用的并发队列实现，分别是：<br><strong>ConcurrentLinkedQueue、LinkedBlockingQueue 和 ArrayBlockingQueue</strong> 。</p>
<blockquote>
<p>ArrayBlockingQueue 是 <strong>初始容量固定的阻塞队列</strong><br>，我们可以用来作为数据库模块成功竞拍的队列，比如有 10 个商品，那么我们就设定一个 10 大小的数组队列。<br>ConcurrentLinkedQueue 使用的是 <strong>CAS 原语无锁队列实现，是一个异步队列</strong> ，入队的速度很快，出队进行了加锁，性能稍慢。<br>LinkedBlockingQueue 也是 <strong>阻塞的队列，入队和出队都用了加锁</strong> ，当队空的时候线程会暂时阻塞。</p>
</blockquote>
<p>由于我们的系统 <strong>入队需求要远大于出队需求</strong><br>，一般不会出现队空的情况，所以我们可以选择 ConcurrentLinkedQueue 来作为我们的请求队列实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package seckill;  </span><br><span class="line">    import java.util.concurrent.ArrayBlockingQueue;  </span><br><span class="line">    import java.util.concurrent.ConcurrentLinkedQueue;  </span><br><span class="line">    import org.apache.http.HttpRequest;  </span><br><span class="line">    public class RequestQueue &#123;  </span><br><span class="line">            public static ConcurrentLinkedQueue&lt;HttpRequest&gt; queue &#x3D; new ConcurrentLinkedQueue&lt;HttpRequest&gt;();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><strong>用户请求模块</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package seckill;  </span><br><span class="line">    import org.apache.http.HttpRequest;  </span><br><span class="line">    public class Processor &#123;  </span><br><span class="line">        &#x2F;**  </span><br><span class="line">         * 发送秒杀事务到数据库队列.  </span><br><span class="line">         *&#x2F;  </span><br><span class="line">        public static void kill(BidInfo info) &#123;  </span><br><span class="line">            DB.bids.add(info);  </span><br><span class="line">        &#125;  </span><br><span class="line">        public static void process() &#123;  </span><br><span class="line">            BidInfo info &#x3D; new BidInfo(RequestQueue.queue.poll());  </span><br><span class="line">            if (info !&#x3D; null) &#123;  </span><br><span class="line">                kill(info);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    class BidInfo &#123;  </span><br><span class="line">        BidInfo(HttpRequest request) &#123;  </span><br><span class="line">            &#x2F;&#x2F; Do something.  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><strong>数据库模块</strong>  <br>数据库主要是使用一个 ArrayBlockingQueue 来暂存有可能成功的用户请求。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package seckill;  </span><br><span class="line">    import java.util.concurrent.ArrayBlockingQueue;  </span><br><span class="line">    &#x2F;**  </span><br><span class="line">        * DB应该是数据库的唯一接口.  </span><br><span class="line">        *&#x2F;  </span><br><span class="line">    public class DB &#123;  </span><br><span class="line">          public static int count &#x3D; 10;  </span><br><span class="line">          public static ArrayBlockingQueue&lt;BidInfo&gt; bids &#x3D; new ArrayBlockingQueue&lt;BidInfo&gt;(10);  </span><br><span class="line">          public static boolean checkReminds() &#123;  </span><br><span class="line">              &#x2F;&#x2F; TODO  </span><br><span class="line">              return true;  </span><br><span class="line">          &#125;  </span><br><span class="line">          &#x2F;&#x2F; 单线程操作  </span><br><span class="line">          public static void bid() &#123;  </span><br><span class="line">              BidInfo info &#x3D; bids.poll();  </span><br><span class="line">              while (count-- &gt; 0) &#123;  </span><br><span class="line">                  &#x2F;&#x2F; insert into table Bids values(item_id, user_id, bid_date, other)  </span><br><span class="line">                  &#x2F;&#x2F; select count(id) from Bids where item_id &#x3D; ?  </span><br><span class="line">                  &#x2F;&#x2F; 如果数据库商品数量大约总数，则标志秒杀已完成，设置标志位reminds &#x3D; false.  </span><br><span class="line">                  info &#x3D; bids.poll();  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-4-数据库设计"><a href="#4-4-数据库设计" class="headerlink" title="4.4 数据库设计"></a>4.4 数据库设计</h2><h3 id="4-4-1-基本概念"><a href="#4-4-1-基本概念" class="headerlink" title="4.4.1 基本概念"></a>4.4.1 基本概念</h3><p><strong>概念一 “单库”</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316921-4e81c2d4-6d8f-4d45-84ad-a6e26e339283.png#align=left&display=inline&height=47&margin=%5Bobject%20Object%5D&originHeight=47&originWidth=95&size=0&status=done&style=none&width=95" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316921-4e81c2d4-6d8f-4d45-84ad-a6e26e339283.png#align=left&display=inline&height=47&margin=%5Bobject%20Object%5D&originHeight=47&originWidth=95&size=0&status=done&style=none&width=95" srcset="data:image/png;base64,666"></p>
<p>概念一 “单库”</p>
<p><strong>概念二 “分片”</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316859-af26ffaf-3b86-42f6-aa70-6445c9cf7058.png#align=left&display=inline&height=50&margin=%5Bobject%20Object%5D&originHeight=50&originWidth=150&size=0&status=done&style=none&width=150" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316859-af26ffaf-3b86-42f6-aa70-6445c9cf7058.png#align=left&display=inline&height=50&margin=%5Bobject%20Object%5D&originHeight=50&originWidth=150&size=0&status=done&style=none&width=150" srcset="data:image/png;base64,666"></p>
<p>概念二 “分片”</p>
<p><strong>分片解决的是 “数据量太大” 的问题，也就是通常说的“水平切分”</strong> 。一旦引入分片，势必有 “数据路由” 的概念，哪个数据访问哪个库。路由规则通常有 3 种方法：</p>
<ol>
<li><strong>范围：range</strong></li>
</ol>
<blockquote>
<p>优点：简单，容易扩展<br>缺点：各库压力不均（新号段更活跃）</p>
</blockquote>
<ol start="2">
<li><strong>哈希：hash 【大部分互联网公司采用的方案二：哈希分库，哈希路由】</strong></li>
</ol>
<blockquote>
<p>优点：简单，数据均衡，负载均匀<br>缺点：迁移麻烦（2 库扩 3 库数据要迁移）</p>
</blockquote>
<ol start="3">
<li><strong>路由服务：router-config-server</strong></li>
</ol>
<blockquote>
<p>优点：灵活性强，业务与路由算法解耦<br>缺点：每次访问数据库前多一次查询</p>
</blockquote>
<p><strong>概念三 “分组”</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316867-c8743ba8-0ccf-4b64-b4b5-61646b650d3e.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&originHeight=89&originWidth=183&size=0&status=done&style=none&width=183" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316867-c8743ba8-0ccf-4b64-b4b5-61646b650d3e.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&originHeight=89&originWidth=183&size=0&status=done&style=none&width=183" srcset="data:image/png;base64,666"></p>
<p>概念三 “分组”</p>
<p>分组解决 “可用性” 问题，分组通常通过 <strong>主从复制</strong> 的方式实现。</p>
<p><strong>互联网公司数据库实际软件架构是：又分片，又分组（如下图）</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316971-082d9221-82d8-4505-a1d5-2375ace82cec.png#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&originHeight=104&originWidth=304&size=0&status=done&style=none&width=304" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316971-082d9221-82d8-4505-a1d5-2375ace82cec.png#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&originHeight=104&originWidth=304&size=0&status=done&style=none&width=304" srcset="data:image/png;base64,666"></p>
<p>又分片，又分组</p>
<h3 id="4-4-2-设计思路"><a href="#4-4-2-设计思路" class="headerlink" title="4.4.2 设计思路"></a>4.4.2 设计思路</h3><p>数据库软件架构师平时设计些什么东西呢？至少要考虑以下四点：</p>
<blockquote>
<ol>
<li>如何保证数据可用性；</li>
<li>如何提高数据库读性能（大部分应用读多写少，读会先成为瓶颈）；</li>
<li>如何保证一致性；</li>
<li>如何提高扩展性；</li>
</ol>
</blockquote>
<ol>
<li><strong>如何保证数据的可用性？</strong></li>
</ol>
<p><strong>解决可用性问题的思路是 = &gt; 冗余</strong></p>
<blockquote>
<p>如何保证站点的可用性？复制站点，冗余站点<br>如何保证服务的可用性？复制服务，冗余服务<br>如何保证数据的可用性？复制数据，冗余数据</p>
</blockquote>
<p><strong>数据的冗余，会带来一个副作用 = &gt; 引发一致性问题（先不说一致性问题，先说可用性）。</strong></p>
<ol start="2">
<li><strong>如何保证数据库 “读” 高可用？</strong></li>
</ol>
<p><strong>冗余读库</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316822-40ea08b1-91a2-46f6-a30e-8602d747b898.png#align=left&display=inline&height=145&margin=%5Bobject%20Object%5D&originHeight=145&originWidth=216&size=0&status=done&style=none&width=216" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316822-40ea08b1-91a2-46f6-a30e-8602d747b898.png#align=left&display=inline&height=145&margin=%5Bobject%20Object%5D&originHeight=145&originWidth=216&size=0&status=done&style=none&width=216" srcset="data:image/png;base64,666"></p>
<p>读高可用</p>
<p><strong>冗余读库带来的副作用？读写有延时，可能不一致</strong> 。</p>
<p>上面这个图是很多互联网公司 mysql 的架构，写仍然是单点，不能保证写高可用。</p>
<ol start="3">
<li><strong>如何保证数据库 “写” 高可用？</strong></li>
</ol>
<p><strong>冗余写库</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316874-b7881a58-7d60-4428-ad7c-cf16c5e1d9d8.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=148&originWidth=256&size=0&status=done&style=none&width=256" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316874-b7881a58-7d60-4428-ad7c-cf16c5e1d9d8.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=148&originWidth=256&size=0&status=done&style=none&width=256" srcset="data:image/png;base64,666"></p>
<p>写高可用</p>
<p><strong>采用双主互备的方式，可以冗余写库带来的副作用？双写同步，数据可能冲突（例如 “自增 id” 同步冲突）</strong> ，如何解决同步冲突，有两种常见解决方案：</p>
<blockquote>
<ol>
<li>两个写库使用不同的初始值，相同的步长来增加 id：1 写库的 id 为 0,2,4,6…；2 写库的 id 为 1,3,5,7…；</li>
<li>不使用数据的 id，业务层自己生成唯一的 id，保证数据不冲突；</li>
</ol>
</blockquote>
<p><strong>实际中没有使用上述两种架构来做读写的 “高可用”，采用的是“双主当主从用” 的方式：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317019-16417451-7f44-4677-9442-65989ea5fb62.png#align=left&display=inline&height=125&margin=%5Bobject%20Object%5D&originHeight=125&originWidth=109&size=0&status=done&style=none&width=109" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317019-16417451-7f44-4677-9442-65989ea5fb62.png#align=left&display=inline&height=125&margin=%5Bobject%20Object%5D&originHeight=125&originWidth=109&size=0&status=done&style=none&width=109" srcset="data:image/png;base64,666"></p>
<p>双主当主从用</p>
<p>仍是双主，但 <strong>只有一个主提供服务（读 + 写），另一个主是 “shadow-master”，只用来保证高可用，平时不提供服务</strong> 。</p>
<p>master 挂了，shadow-master 顶上（vip 漂移，对业务层透明，不需要人工介入）。这种方式的好处：</p>
<blockquote>
<ol>
<li>读写没有延时；</li>
<li>读写高可用；</li>
</ol>
</blockquote>
<p>不足：</p>
<blockquote>
<ol>
<li>不能通过加从库的方式扩展读性能；</li>
<li>资源利用率为 50%，一台冗余主没有提供服务；</li>
</ol>
</blockquote>
<p>那如何提高读性能呢？进入第二个话题，如何提供读性能。</p>
<ol start="4">
<li><strong>如何扩展读性能</strong></li>
</ol>
<p>提高读性能的方式大致有三种， <strong>第一种是建立索引</strong> 。这种方式不展开，要提到的一点是， <strong>不同的库可以建立不同的索引</strong> 。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317021-ee7c5436-e255-4024-b6cd-f21c75663f12.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=150&originWidth=278&size=0&status=done&style=none&width=278" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317021-ee7c5436-e255-4024-b6cd-f21c75663f12.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=150&originWidth=278&size=0&status=done&style=none&width=278" srcset="data:image/png;base64,666"></p>
<p>不同的库可以建立不同的索引</p>
<blockquote>
<p><strong>写库</strong> 不建立索引；<br><strong>线上读库</strong> 建立线上访问索引，例如 uid；<br><strong>线下读库</strong> 建立线下访问索引，例如 time；</p>
</blockquote>
<p><strong>第二种扩充读性能的方式是，增加从库</strong> ，这种方法大家用的比较多，但是，存在两个缺点：</p>
<blockquote>
<ol>
<li>从库越多，同步越慢；</li>
<li>同步越慢，数据不一致窗口越大（不一致后面说，还是先说读性能的提高）；</li>
</ol>
</blockquote>
<p>实际中没有采用这种方法提高数据库读性能（没有从库）， <strong>采用的是增加缓存</strong> 。常见的缓存架构如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317015-e67b88fd-515a-4892-9736-b9b23d33bd9a.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&originHeight=158&originWidth=247&size=0&status=done&style=none&width=247" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317015-e67b88fd-515a-4892-9736-b9b23d33bd9a.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&originHeight=158&originWidth=247&size=0&status=done&style=none&width=247" srcset="data:image/png;base64,666"></p>
<p>常见玩法：数据库 + 缓存</p>
<p>上游是业务应用，下游是主库，从库（读写分离），缓存。实际的玩法：<strong>服务 + 数据库 + 缓存一套</strong> 。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317023-aa245628-d118-422a-a435-903eefd30395.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&originHeight=237&originWidth=174&size=0&status=done&style=none&width=174" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317023-aa245628-d118-422a-a435-903eefd30395.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&originHeight=237&originWidth=174&size=0&status=done&style=none&width=174" srcset="data:image/png;base64,666"></p>
<p>服务 + 数据库 + 缓存一套</p>
<p>业务层不直接面向 db 和 cache， <strong>服务层屏蔽了底层 db、cache 的复杂性</strong><br>。为什么要引入服务层，今天不展开，采用了 “服务 + 数据库 + 缓存一套” 的方式提供数据访问， <strong>用 cache 提高读性能</strong> 。</p>
<blockquote>
<p><strong>不管采用主从的方式扩展读性能，还是缓存的方式扩展读性能，数据都要复制多份（主 + 从，db+cache），一定会引发一致性问题。</strong></p>
</blockquote>
<ol start="5">
<li><strong>如何保证一致性？</strong></li>
</ol>
<p>主从数据库的一致性，通常有两种解决方案：</p>
<ol>
<li><strong>中间件</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317066-d436d6c6-23f5-4f0a-b372-c7d9f54be7bb.png#align=left&display=inline&height=137&margin=%5Bobject%20Object%5D&originHeight=137&originWidth=279&size=0&status=done&style=none&width=279" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317066-d436d6c6-23f5-4f0a-b372-c7d9f54be7bb.png#align=left&display=inline&height=137&margin=%5Bobject%20Object%5D&originHeight=137&originWidth=279&size=0&status=done&style=none&width=279" srcset="data:image/png;base64,666"></p>
<p>中间件</p>
<p>如果某一个 key 有写操作，在不一致时间窗口内，中间件会将这个 key 的读操作也路由到主库上。这个方案的缺点是， <strong>数据库中间件的门槛较高</strong><br>（百度，腾讯，阿里，360 等一些公司有）。</p>
<ol start="2">
<li><strong>强制读主</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317008-e66b60b0-4957-49f1-b60d-984e03637214.png#align=left&display=inline&height=126&margin=%5Bobject%20Object%5D&originHeight=126&originWidth=85&size=0&status=done&style=none&width=85" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317008-e66b60b0-4957-49f1-b60d-984e03637214.png#align=left&display=inline&height=126&margin=%5Bobject%20Object%5D&originHeight=126&originWidth=85&size=0&status=done&style=none&width=85" srcset="data:image/png;base64,666"></p>
<p>强制读主</p>
<p>上面实际用的 “双主当主从用” 的架构，不存在主从不一致的问题。第二类不一致， <strong>是 db 与缓存间的不一致</strong> ：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316973-de5f0fe2-a812-45e7-93c0-c88580460a12.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&originHeight=158&originWidth=247&size=0&status=done&style=none&width=247" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316973-de5f0fe2-a812-45e7-93c0-c88580460a12.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&originHeight=158&originWidth=247&size=0&status=done&style=none&width=247" srcset="data:image/png;base64,666"></p>
<p>常见玩法：数据库 + 缓存</p>
<p>常见的缓存架构如上，此时 <strong>写操作</strong> 的顺序是：</p>
<blockquote>
<p>（1）淘汰 cache；<br>（2）写数据库；</p>
</blockquote>
<p><strong>读操作</strong> 的顺序是：</p>
<blockquote>
<p>（1）读 cache，如果 cache hit 则返回；<br>（2）如果 cache miss，则读从库；<br>（3）读从库后，将数据放回 cache；</p>
</blockquote>
<p>在一些异常时序情况下，有可能从【从库读到旧数据（同步还没有完成），旧数据入 cache 后】，数据会长期不一致。<code>解决办法是“缓存双淘汰”</code><br>，写操作时序升级为：</p>
<blockquote>
<p>（1）淘汰 cache；<br>（2）写数据库；<br>（3）在经过 “主从同步延时窗口时间” 后，再次发起一个异步淘汰 cache 的请求；</p>
</blockquote>
<p>这样，即使有脏数据如 cache，一个小的时间窗口之后，脏数据还是会被淘汰。带来的代价是，多引入一次读 miss（成本可以忽略）。</p>
<p>除此之外，最佳实践之一是：<strong>建议为所有 cache 中的 item 设置一个超时时间</strong> 。</p>
<ol start="3">
<li><strong>如何提高数据库的扩展性？</strong></li>
</ol>
<p>原来用 hash 的方式路由，分为 2 个库，数据量还是太大，要分为 3 个库，势必需要进行数据迁移，有一个很帅气的 “数据库秒级扩容” 方案。</p>
<p><strong>如何秒级扩容？</strong></p>
<p>首先， <strong>我们不做 2 库变 3 库的扩容，我们做 2 库变 4 库（库加倍）的扩容（未来 4- &gt;8-&gt;16）</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316942-c633ff23-ffd8-4b08-b402-285eadb5ecd9.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&originHeight=114&originWidth=106&size=0&status=done&style=none&width=106" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316942-c633ff23-ffd8-4b08-b402-285eadb5ecd9.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&originHeight=114&originWidth=106&size=0&status=done&style=none&width=106" srcset="data:image/png;base64,666"></p>
<p>原来分 2 库</p>
<p>服务 + 数据库是一套（省去了缓存）， <strong>数据库采用 “双主” 的模式</strong> 。</p>
<p><strong>扩容步骤：</strong></p>
<blockquote>
<p><strong>第一步</strong> ，将一个主库提升;<br><strong>第二步</strong> ，修改配置，2 库变 4 库（原来 MOD2，现在配置修改后 MOD4），扩容完成；</p>
</blockquote>
<p><strong>原 MOD2 为偶的部分，现在会 MOD4 余 0 或者 2；原 MOD2 为奇的部分，现在会 MOD4 余 1 或者 3</strong><br>；数据不需要迁移，同时，双主互相同步，一遍是余 0，一边余 2，两边数据同步也不会冲突，秒级完成扩容！</p>
<p>最后，要做一些收尾工作：</p>
<blockquote>
<ol>
<li>将旧的双主同步解除；</li>
<li>增加新的双主（双主是保证可用性的，shadow-master 平时不提供服务）；</li>
<li>删除多余的数据（余 0 的主，可以将余 2 的数据删除掉）；</li>
</ol>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316994-a9cf87d6-cd70-4826-a7fa-4ea3679f2595.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=270&size=0&status=done&style=none&width=270" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316994-a9cf87d6-cd70-4826-a7fa-4ea3679f2595.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=270&size=0&status=done&style=none&width=270" srcset="data:image/png;base64,666"></p>
<p>2 库变 4 库的扩展</p>
<p>这样，秒级别内，我们就完成了 2 库变 4 库的扩展。</p>
<h1 id="5-大并发带来的挑战"><a href="#5-大并发带来的挑战" class="headerlink" title="5 大并发带来的挑战"></a>5 大并发带来的挑战</h1><h2 id="5-1-请求接口的合理设计"><a href="#5-1-请求接口的合理设计" class="headerlink" title="5.1 请求接口的合理设计"></a>5.1 请求接口的合理设计</h2><p>一个秒杀或者抢购页面，通常分为 2 个部分，一个是 <strong>静态的 HTML 等内容</strong> ，另一个就是 <strong>参与秒杀的 Web 后台请求接口</strong> 。</p>
<p><strong>通常静态 HTML 等内容，是通过 CDN 的部署，一般压力不大，核心瓶颈实际上在后台请求接口上</strong><br>。这个后端接口，必须能够支持高并发请求，同时，非常重要的一点，必须尽可能 “快”，在最短的时间里返回用户的请求结果。<br><strong>为了实现尽可能快这一点，接口的后端存储使用内存级别的操作会更好一点</strong> 。仍然直接面向 MySQL 之类的存储是不合适的，<br><strong>如果有这种复杂业务的需求，都建议采用异步写入</strong> 。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317082-c5ae7c25-3dd4-4c2e-bb90-6454ed8648bf.png#align=left&display=inline&height=320&margin=%5Bobject%20Object%5D&originHeight=320&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317082-c5ae7c25-3dd4-4c2e-bb90-6454ed8648bf.png#align=left&display=inline&height=320&margin=%5Bobject%20Object%5D&originHeight=320&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p>秒杀业务流程设计</p>
<p>当然，也有一些秒杀和抢购 <strong>采用 “滞后反馈”</strong><br>，就是说秒杀当下不知道结果，一段时间后才可以从页面中看到用户是否秒杀成功。但是，这种属于 “偷懒” 行为，同时给用户的体验也不好，容易被用户认为是“暗箱操作”。</p>
<h2 id="5-2-高并发的挑战：一定要-“快”"><a href="#5-2-高并发的挑战：一定要-“快”" class="headerlink" title="5.2 高并发的挑战：一定要 “快”"></a>5.2 高并发的挑战：一定要 “快”</h2><p>我们通常衡量一个 <strong>Web 系统的吞吐率的指标是 QPS（Query Per Second，每秒处理请求数），解决每秒数万次的高并发场景，这个指标非常关键</strong><br>。举个例子，我们假设处理一个业务请求平均响应时间为 100ms，同时，系统内有 20 台 Apache 的 Web 服务器，配置 MaxClients 为 500 个（表示 Apache 的最大连接数目）。</p>
<p>那么，我们的 Web 系统的理论峰值 QPS 为（理想化的计算方式）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20*500&#x2F;0.1 &#x3D; 100000 （10万QPS）</span><br></pre></td></tr></table></figure>


<p>咦？我们的系统似乎很强大，1 秒钟可以处理完 10 万的请求，5w/s 的秒杀似乎是 “纸老虎” 哈。实际情况，当然没有这么理想。<br><strong>在高并发的实际场景下，机器都处于高负载的状态，在这个时候平均响应时间会被大大增加</strong> 。</p>
<p><strong>就 Web 服务器而言，Apache 打开了越多的连接进程，CPU 需要处理的上下文切换也越多，额外增加了 CPU 的消耗，然后就直接导致平均响应时间增加</strong><br>。因此上述的 <strong>MaxClient 数目，要根据 CPU、内存等硬件因素综合考虑，绝对不是越多越好</strong> 。可以<br><strong>通过 Apache 自带的 abench 来测试一下，取一个合适的值</strong> 。然后，我们<br><strong>选择内存操作级别的存储的 Redis，在高并发的状态下，存储的响应时间至关重要</strong><br>。网络带宽虽然也是一个因素，不过，这种请求数据包一般比较小，一般很少成为请求的瓶颈。负载均衡成为系统瓶颈的情况比较少，在这里不做讨论哈。</p>
<p>那么问题来了，假设我们的系统，在 5w/s 的高并发状态下，平均响应时间从 100ms 变为 250ms（实际情况，甚至更多）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20*500&#x2F;0.25 &#x3D; 40000 （4万QPS）</span><br></pre></td></tr></table></figure>


<p>于是，我们的系统剩下了 4w 的 QPS，面对 5w 每秒的请求，中间相差了 1w。</p>
<p>然后，这才是真正的恶梦开始。举个例子，高速路口，1 秒钟来 5 部车，每秒通过 5 部车，高速路口运作正常。突然，这个路口 1 秒钟只能通过 4 部车，车流量仍然依旧，结果必定出现大塞车。（5 条车道忽然变成 4 条车道的感觉）。</p>
<p>同理，某一个秒内，20*500 个可用连接进程都在满负荷工作中，却仍然有 1 万个新来请求，没有连接进程可用，系统陷入到异常状态也是预期之内。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317018-09bfa12d-604b-410d-83cc-743b1d93e3bc.png#align=left&display=inline&height=203&margin=%5Bobject%20Object%5D&originHeight=203&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317018-09bfa12d-604b-410d-83cc-743b1d93e3bc.png#align=left&display=inline&height=203&margin=%5Bobject%20Object%5D&originHeight=203&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p>其实在正常的非高并发的业务场景中，也有类似的情况出现，某个业务请求接口出现问题，响应时间极慢，将整个 Web 请求响应时间拉得很长，逐渐将 Web 服务器的可用连接数占满，其他正常的业务请求，无连接进程可用。</p>
<p>更可怕的问题是，是用户的行为特点，系统越是不可用，用户的点击越频繁，<br><strong>恶性循环最终导致 “雪崩”（其中一台 Web 机器挂了，导致流量分散到其他正常工作的机器上，再导致正常的机器也挂，然后恶性循环）</strong> ，将整个 Web 系统拖垮。</p>
<h2 id="5-3-重启与过载保护"><a href="#5-3-重启与过载保护" class="headerlink" title="5.3 重启与过载保护"></a>5.3 重启与过载保护</h2><p>如果系统发生 “雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候， <strong>最好在入口层将流量拒绝，然后再将重启</strong><br>。如果是 redis/memcache 这种服务也挂了，重启的时候需要注意 “预热”，并且很可能需要比较长的时间。</p>
<p>秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。<strong>如果检测到系统满负载状态，拒绝请求也是一种保护措施</strong><br>。在前端设置过滤是最简单的方式，但是，这种做法是被用户 “千夫所指” 的行为。更合适一点的是， <strong>将过载保护设置在 CGI 入口层，快速将客户的直接请求返回</strong><br>。</p>
<h1 id="6-作弊的手段：进攻与防守"><a href="#6-作弊的手段：进攻与防守" class="headerlink" title="6 作弊的手段：进攻与防守"></a>6 作弊的手段：进攻与防守</h1><p>秒杀和抢购收到了 “海量” 的请求，实际上里面的水分是很大的。不少用户，为了 “抢“到商品，会使用“刷票工具” 等类型的辅助工具，帮助他们发送尽可能多的请求到服务器。还有一部分高级用户，制作强大的自动请求脚本。<br><strong>这种做法的理由也很简单，就是在参与秒杀和抢购的请求中，自己的请求数目占比越多，成功的概率越高</strong> 。</p>
<p>这些都是属于 “作弊的手段”，不过，有“进攻” 就有“防守”，这是一场没有硝烟的战斗哈。</p>
<h2 id="6-1-同一个账号，一次性发出多个请求"><a href="#6-1-同一个账号，一次性发出多个请求" class="headerlink" title="6.1 同一个账号，一次性发出多个请求"></a>6.1 同一个账号，一次性发出多个请求</h2><p>部分用户通过浏览器的插件或者其他工具，在秒杀开始的时间里， <strong>以自己的账号，一次发送上百甚至更多的请求</strong> 。实际上，这样的用户破坏了秒杀和抢购的公平性。</p>
<p>这种请求在某些没有做数据安全处理的系统里，也可能造成另外一种破坏，导致某些判断条件被绕过。例如一个简单的领取逻辑，先判断用户是否有参与记录，如果没有则领取成功，最后写入到参与记录中。这是个非常简单的逻辑，但是，在高并发的场景下，存在深深的漏洞。<br><strong>多个并发请求通过负载均衡服务器，分配到内网的多台 Web 服务器，它们首先向存储发送查询请求，然后，在某个请求成功写入参与记录的时间差内，其他的请求获查询到的结果都是 “没有参与记录”</strong><br>。这里，就存在逻辑判断被绕过的风险。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316927-4a4dab56-5906-467d-9a7d-5aa87e997cac.png#align=left&display=inline&height=263&margin=%5Bobject%20Object%5D&originHeight=263&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316927-4a4dab56-5906-467d-9a7d-5aa87e997cac.png#align=left&display=inline&height=263&margin=%5Bobject%20Object%5D&originHeight=263&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p><strong>应对方案：</strong></p>
<p>在程序入口处，一个账号只允许接受 1 个请求，其他请求过滤。不仅解决了同一个账号，发送 N 个请求的问题，还保证了后续的逻辑流程的安全。<br><strong>实现方案，可以通过 Redis 这种内存缓存服务，写入一个标志位（只允许 1 个请求写成功，结合 watch 的乐观锁的特性），成功写入的则可以继续参加</strong> 。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317151-6053d90d-344d-4d26-ae7b-298f0d7cba15.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317151-6053d90d-344d-4d26-ae7b-298f0d7cba15.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p>或者，自己实现一个服务，将同一个账号的请求放入一个队列中，处理完一个，再处理下一个。</p>
<h2 id="6-2-多个账号，一次性发送多个请求"><a href="#6-2-多个账号，一次性发送多个请求" class="headerlink" title="6.2 多个账号，一次性发送多个请求"></a>6.2 多个账号，一次性发送多个请求</h2><p>很多公司的账号注册功能，在发展早期几乎是没有限制的，很容易就可以注册很多个账号。因此，<br><strong>也导致了出现了一些特殊的工作室，通过编写自动注册脚本，积累了一大批 “僵尸账号”，数量庞大，几万甚至几十万的账号不等，专门做各种刷的行为（这就是微博中的 “僵尸粉 “的来源）</strong><br>。举个例子，例如微博中有转发抽奖的活动，如果我们使用几万个 “僵尸号” 去混进去转发，这样就可以大大提升我们中奖的概率。</p>
<p>这种账号，使用在秒杀和抢购里，也是同一个道理。例如，iPhone 官网的抢购，火车票黄牛党。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317035-4dab5289-75a3-4c7c-a7ce-ffc40921d81e.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&originHeight=235&originWidth=369&size=0&status=done&style=none&width=369" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317035-4dab5289-75a3-4c7c-a7ce-ffc40921d81e.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&originHeight=235&originWidth=369&size=0&status=done&style=none&width=369" srcset="data:image/png;base64,666"></p>
<p><strong>应对方案：</strong></p>
<p>这种场景，可以 <strong>通过检测指定机器 IP 请求频率就可以解决，如果发现某个 IP 请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求</strong> ：</p>
<blockquote>
<ol>
<li><strong>弹出验证码，最核心的追求，就是分辨出真实用户。</strong><br>因此，大家可能经常发现，网站弹出的验证码，有些是 “鬼神乱舞” 的样子，有时让我们根本无法看清。他们这样做的原因，其实也是为了让验证码的图片不被轻易识别，因为强大的 “自动脚本” 可以通过图片识别里面的字符，然后让脚本自动填写验证码。实际上，有一些非常创新的验证码，效果会比较好，例如给你一个简单问题让你回答，或者让你完成某些简单操作（例如百度贴吧的验证码）。</li>
<li><strong>直接禁止 IP，实际上是有些粗暴的，因为有些真实用户的网络场景恰好是同一出口 IP 的，可能会有 “误伤 “</strong><br>。但是这一个做法简单高效，根据实际场景使用可以获得很好的效果。</li>
</ol>
</blockquote>
<h2 id="6-3-多个账号，不同-IP-发送不同请求"><a href="#6-3-多个账号，不同-IP-发送不同请求" class="headerlink" title="6.3 多个账号，不同 IP 发送不同请求"></a>6.3 多个账号，不同 IP 发送不同请求</h2><p>所谓道高一尺，魔高一丈。有进攻，就会有防守，永不休止。<br><strong>这些 “工作室”，发现你对单机 IP 请求频率有控制之后，他们也针对这种场景，想出了他们的 “新进攻方案”，就是不断改变 IP</strong> 。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317038-f44be557-65bb-4add-ada0-f8b7ba9c1978.png#align=left&display=inline&height=98&margin=%5Bobject%20Object%5D&originHeight=98&originWidth=401&size=0&status=done&style=none&width=401" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317038-f44be557-65bb-4add-ada0-f8b7ba9c1978.png#align=left&display=inline&height=98&margin=%5Bobject%20Object%5D&originHeight=98&originWidth=401&size=0&status=done&style=none&width=401" srcset="data:image/png;base64,666"></p>
<p>有同学会好奇，这些随机 IP 服务怎么来的。<strong>有一些是某些机构自己占据一批独立 IP，然后做成一个随机代理 IP 的服务，有偿提供给这些 “工作室” 使用</strong><br>。还有一些更为黑暗一点的，就是<br><strong>通过木马黑掉普通用户的电脑，这个木马也不破坏用户电脑的正常运作，只做一件事情，就是转发 IP 包，普通用户的电脑被变成了 IP 代理出口</strong><br>。通过这种做法，黑客就拿到了大量的独立 IP，然后搭建为随机 IP 服务，就是为了挣钱。</p>
<p><strong>应对方案：</strong></p>
<p>说实话，这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易 “误伤 “真实用户，这个时候，<br><strong>通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的” 数据挖掘 “来提前清理掉它们</strong> 。</p>
<p>僵尸账号也还是有一些共同特征的，例如 <strong>账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等</strong><br>。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。<strong>通过这些业务手段，也是可以过滤掉一些僵尸号</strong> 。</p>
<h1 id="7-高并发下的数据安全"><a href="#7-高并发下的数据安全" class="headerlink" title="7 高并发下的数据安全"></a>7 高并发下的数据安全</h1><p>我们知道在 <strong>多线程写入同一个文件的时候，会存现 “线程安全” 的问题</strong><br>（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是线程安全的）。<br><strong>如果是 MySQL 数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用 MySQL 的</strong> 。<br><strong>秒杀和抢购的场景中，还有另外一个问题，就是 “超发”，如果在这方面控制不慎，会产生发送过多的情况</strong><br>。我们也曾经听说过，某些电商搞抢购活动，买家成功拍下后，商家却不承认订单有效，拒绝发货。这里的问题，也许并不一定是商家奸诈，而是系统技术层面存在超发风险导致的。</p>
<h2 id="7-1-超发的原因"><a href="#7-1-超发的原因" class="headerlink" title="7.1 超发的原因"></a>7.1 超发的原因</h2><p>假设某个抢购场景中，我们一共只有 100 个商品，在最后一刻，我们已经消耗了 99 个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是 99 个，然后都通过了这一个余量判断，最终导致超发。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317148-2b2a5d69-2bc8-471c-813b-923c76d2c6a7.png#align=left&display=inline&height=282&margin=%5Bobject%20Object%5D&originHeight=282&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317148-2b2a5d69-2bc8-471c-813b-923c76d2c6a7.png#align=left&display=inline&height=282&margin=%5Bobject%20Object%5D&originHeight=282&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p>在上面的这个图中，就导致了并发用户 B 也 “抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。</p>
<h2 id="7-2-悲观锁思路"><a href="#7-2-悲观锁思路" class="headerlink" title="7.2 悲观锁思路"></a>7.2 悲观锁思路</h2><p>解决线程安全的思路很多，可以从 “悲观锁” 的方向开始讨论。</p>
<blockquote>
<p><strong>悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。</strong></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316973-9517f629-1294-427a-83f1-4f8f35854bed.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&originHeight=207&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503316973-9517f629-1294-427a-83f1-4f8f35854bed.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&originHeight=207&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p>虽然上述的方案的确解决了线程安全的问题，但是，别忘记，<br><strong>我们的场景是 “高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待 “锁”，某些线程可能永远都没有机会抢到这个 “锁”，这种请求就会死在那里</strong><br>。同时，这种请求会很多， <strong>瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常</strong> 。</p>
<h2 id="7-3-FIFO-队列思路"><a href="#7-3-FIFO-队列思路" class="headerlink" title="7.3 FIFO 队列思路"></a>7.3 FIFO 队列思路</h2><p>那好，那么我们稍微修改一下上面的场景， <strong>我们直接将请求放入队列中的，采用 FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁</strong> 。看到这里，是不是有点强行将多线程变成单线程的感觉哈。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317109-73ec0cc9-842c-4997-9984-33c956ab1e3c.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&originHeight=170&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317109-73ec0cc9-842c-4997-9984-33c956ab1e3c.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&originHeight=170&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p>然后，我们现在解决了锁的问题，全部请求采用 “先进先出” 的队列方式来处理。那么新的问题来了，<br><strong>高并发的场景下，因为请求很多，很可能一瞬间将队列内存 “撑爆”，然后系统又陷入到了异常状态</strong><br>。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终 Web 系统平均响应时候还是会大幅下降，系统还是陷入异常。</p>
<h2 id="7-4-乐观锁思路"><a href="#7-4-乐观锁思路" class="headerlink" title="7.4 乐观锁思路"></a>7.4 乐观锁思路</h2><p>这个时候，我们就可以讨论一下 “乐观锁” 的思路了。<strong>乐观锁，是相对于 “悲观锁” 采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。</strong><br>实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，<br><strong>它会增大 CPU 的计算开销</strong> 。但是，综合来说，这是一个比较好的解决方案。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317152-765fd3a0-48ac-489e-ab54-59474dcf9873.png#align=left&display=inline&height=127&margin=%5Bobject%20Object%5D&originHeight=127&originWidth=600&size=0&status=done&style=none&width=600" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317152-765fd3a0-48ac-489e-ab54-59474dcf9873.png#align=left&display=inline&height=127&margin=%5Bobject%20Object%5D&originHeight=127&originWidth=600&size=0&status=done&style=none&width=600" srcset="data:image/png;base64,666"></p>
<p>有很多软件和服务都 “乐观锁” 功能的支持，例如 <strong>Redis 中的 watch 就是其中之一</strong> 。通过这个实现，我们保证了数据的安全。</p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>互联网正在高速发展，使用互联网服务的用户越多，高并发的场景也变得越来越多。电商秒杀和抢购，是两个比较典型的互联网高并发场景。虽然我们解决问题的具体技术方案可能千差万别，但是遇到的挑战却是相似的，因此解决问题的思路也异曲同工。</p>
<p>end</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/gif/1983805/1604503317080-88e2afe0-187f-4cb9-865e-4fb0d9e3f8ff.gif#align=left&display=inline&height=10&margin=%5Bobject%20Object%5D&originHeight=10&originWidth=22&size=0&status=done&style=none&width=22" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/1983805/1604503317080-88e2afe0-187f-4cb9-865e-4fb0d9e3f8ff.gif#align=left&display=inline&height=10&margin=%5Bobject%20Object%5D&originHeight=10&originWidth=22&size=0&status=done&style=none&width=22" srcset="data:image/png;base64,666"></p>
<p>有热门推荐👇</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247486926&idx=1&sn=ee08add31e803e646346eb0b08c8a492&chksm=fbf7e40ccc806d1aba39ae4798dfb564b8da45abbfa74bc24d1a138b58fbee9db9674df79333&scene=21#wechat_redirect">万字带你入门 Netty ！高手勿入！！！</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247486746&idx=1&sn=1293af0eda09c322f0b1b66e10244414&chksm=fbf7e4d8cc806dcebf29cdf47a7a2eabedf6ae6875cefa24b01b0885e016e7761141b1100e31&scene=21#wechat_redirect">SpringMVC+Spring+Mybatis 支付宝支付功能实战（图文详解）</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247486709&idx=1&sn=adfaf412e85abc28e8e8923567306552&chksm=fbf7e537cc806c21315e91c002a9eb8db971d52c6109126bc1017c62b8a811689dabbb7181d3&scene=21#wechat_redirect">【简历加分】hexo 框架搭建个人博客站点，手把手教学。</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247486630&idx=1&sn=1a52f0bf5e074451f39287ea80bfa89f&chksm=fbf7e564cc806c729d1a59372d921a42a361ca7c41dddcf39ad1d0cf876c0f356059ad720c81&scene=21#wechat_redirect">图解 MyBatis 的 SQL 执行流程（干货）</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247486624&idx=1&sn=1e0a5732ce76f01bd02bdb1183820cd5&chksm=fbf7e562cc806c74fbb3e666dba91725c3ffc1cb097c123e16d4eed3627df8a1988385fde14a&scene=21#wechat_redirect">牛逼，手撸一个 SpringBoot 缓存系统！</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247486620&idx=1&sn=25c45b3eeed37e0815acee5317ffa346&chksm=fbf7e55ecc806c48911af579867660f8e4ad9d4d00dfebd7b31169682a1fbd7b2fd3a05b3bc2&scene=21#wechat_redirect">3W 字的 Spring Boot 超详细总结（硬核干货）</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1983805/1604503317206-ec0394f0-d9bd-46be-a5ca-a2d710539402.jpeg#align=left&display=inline&height=486&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=932&size=0&status=done&style=none&width=932" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/1983805/1604503317206-ec0394f0-d9bd-46be-a5ca-a2d710539402.jpeg#align=left&display=inline&height=486&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=932&size=0&status=done&style=none&width=932" srcset="data:image/png;base64,666"></p>
<p>如有收获，点个在看，诚挚感谢<img src="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317080-425fbce8-120d-4490-84f1-6ef2071ba154.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&originHeight=160&originWidth=160&size=0&status=done&style=none&width=160" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1983805/1604503317080-425fbce8-120d-4490-84f1-6ef2071ba154.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&originHeight=160&originWidth=160&size=0&status=done&style=none&width=160" srcset="data:image/png;base64,666"></p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://example.com/2020/12/01/%E4%B8%87%E5%AD%97%E5%A5%BD%E6%96%87%EF%BC%8C%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%81/>http://example.com/2020/12/01/%E4%B8%87%E5%AD%97%E5%A5%BD%E6%96%87%EF%BC%8C%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%81/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-12-01T11:24:45+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020年12月1日</p>
  </a>
</div>

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/2020/12/01/%E4%B8%87%E5%AD%97%E5%A5%BD%E6%96%87%EF%BC%8C%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%81/&title= - 任大的博客&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://example.com/2020/12/01/%E4%B8%87%E5%AD%97%E5%A5%BD%E6%96%87%EF%BC%8C%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%81/&title= - 任大的博客&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/2020/12/01/%E4%B8%87%E5%AD%97%E5%A5%BD%E6%96%87%EF%BC%8C%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%81/&title= - 任大的博客&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
      
        <a class='next' href='/2020/12/01/hello-world/'>
          <p class='title'>Hello World<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any ...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%89%8D%E7%AB%AF%E5%B1%82%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.1 前端层设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%AB%99%E7%82%B9%E5%B1%82%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.2 站点层设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%9C%8D%E5%8A%A1%E5%B1%82%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.3 服务层设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.4 数据库设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">4.4.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-text">4.4.2 设计思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%90%88%E7%90%86%E8%AE%BE%E8%AE%A1"><span class="toc-text">5.1 请求接口的合理设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%8C%91%E6%88%98%EF%BC%9A%E4%B8%80%E5%AE%9A%E8%A6%81-%E2%80%9C%E5%BF%AB%E2%80%9D"><span class="toc-text">5.2 高并发的挑战：一定要 “快”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%87%8D%E5%90%AF%E4%B8%8E%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4"><span class="toc-text">5.3 重启与过载保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%90%8C%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E5%8F%91%E5%87%BA%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82"><span class="toc-text">6.1 同一个账号，一次性发出多个请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E5%8F%91%E9%80%81%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82"><span class="toc-text">6.2 多个账号，一次性发送多个请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7%EF%BC%8C%E4%B8%8D%E5%90%8C-IP-%E5%8F%91%E9%80%81%E4%B8%8D%E5%90%8C%E8%AF%B7%E6%B1%82"><span class="toc-text">6.3 多个账号，不同 IP 发送不同请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%B6%85%E5%8F%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">7.1 超发的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%82%B2%E8%A7%82%E9%94%81%E6%80%9D%E8%B7%AF"><span class="toc-text">7.2 悲观锁思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-FIFO-%E9%98%9F%E5%88%97%E6%80%9D%E8%B7%AF"><span class="toc-text">7.3 FIFO 队列思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%B9%90%E8%A7%82%E9%94%81%E6%80%9D%E8%B7%AF"><span class="toc-text">7.4 乐观锁思路</span></a></li></ol>
    </div>
  </section>


  


</aside>



        
        
          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=false;
  pdata.postTitle="";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        
      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a id="s-top" class="fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <script>
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/********************脚本懒加载函数********************************/
function loadScript(src, cb) {
var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
var script = document.createElement('script');
script.setAttribute('type','text/javascript');
if (cb) script.onload = cb;
script.setAttribute('src', src);
HEAD.appendChild(script);
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  










  
  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/valine.min.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";

    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      recordIP: 'false',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>





  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/app.min.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/search/hexo.min.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://example.com' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://example.com' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://example.com' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
       

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      
	 

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
      } catch (e) {
        console.log(e);
      }
	  
    });

    document.addEventListener('pjax:error', function (e) {
	  
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
